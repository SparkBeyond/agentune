from __future__ import annotations

import contextlib
from collections.abc import Iterator
from enum import Enum
from typing import Any, Self

import duckdb
from duckdb import DuckDBPyConnection, DuckDBPyRelation


@contextlib.contextmanager
def transaction_scope(conn: DuckDBPyConnection) -> Iterator[DuckDBPyConnection]:
    conn.begin()
    try:
        yield conn
        conn.commit()
    except:
        conn.rollback()
        raise


def results_iter(src: DuckDBPyConnection | DuckDBPyRelation, batch_size: int = 100) -> Iterator[tuple[Any, ...]]:
    # More efficient to call fetchmany() and then flatten
    while True:
        batch = src.fetchmany(batch_size)
        if not batch:
            break
        yield from batch

class ConnectionWithInit:
    """Wrap a DuckDBPyConnection and call execute(self._statement) on every cursor() created before returning it.

    The returned cursors will also be wrapped in an instance of this class.

    Instances of this class are valid connections on a protocol (i.e. duck typing) level, but are not instances
    of DuckDBPyConnection according to isinstance/type and cannot be passed as arguments to duckdb functions
    expecting real connections.

    Does NOT call execute(self._statement) on the original connection.
    """
    def __init__(self, conn: DuckDBPyConnection, statement: str) -> None:
        self._conn = conn
        self._statement = statement

    def __getattr__(self, name: str, /) -> Any:
        return getattr(self._conn, name)

    # Dunder methods we want to forward (__getattr__ isn't called for dunder methods)
    def __enter__(self) -> Self:
        self._conn.__enter__()
        return self

    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None:
        return self._conn.__exit__(exc_type, exc_val, exc_tb)

    def cursor(self) -> ConnectionWithInit:
        curs = self._conn.cursor()
        try:
            curs.execute(self._statement)
        except:
            curs.close()
            raise
        return ConnectionWithInit(curs, self._statement)

    @staticmethod
    def use(conn: DuckDBPyConnection, namespace: str) -> ConnectionWithInit:
        """Issue a USE statement when creating a cursor.

        The namespace is NOT additionally quoted.
        """
        return ConnectionWithInit(conn, f'USE {namespace}')


class RowidNature(Enum):
    """Whether a relation has a rowid member.

    Relations with an explicitly defined column named rowid are COLUMN.
    Native duckdb tables with no explicitly defined column named rowid have an autogenerated column named that, PSEUDOCOLUMN.
    Other relations (e.g. from remote sources, or registered ones) don't have an accessible rowid member, NONE.
    """
    COLUMN = 1
    PSEUDOCOLUMN = 2
    NONE = 3

def test_rowid_nature(conn: DuckDBPyConnection, name: str) -> RowidNature:
    """The argument must be a relation name available on this connection.

    When passing a DuckdbName, remember to apply str().
    """
    rel = conn.table(name)
    if 'rowid' in rel.columns:
        return RowidNature.COLUMN
    else:
        try:
            conn.sql(f'select rowid from {name}')
            return RowidNature.PSEUDOCOLUMN
        except duckdb.BinderException:
            return RowidNature.NONE
