from __future__ import annotations

import asyncio
import contextlib
import datetime
from collections.abc import Generator, Iterator
from enum import Enum
from typing import Any, Self

import duckdb
from duckdb import DuckDBPyConnection, DuckDBPyRelation

from agentune.core.util import asyncref


@contextlib.contextmanager
def transaction_scope(conn: DuckDBPyConnection) -> Iterator[DuckDBPyConnection]:
    conn.begin()
    try:
        yield conn
        conn.commit()
    except:
        conn.rollback()
        raise


def results_iter(src: DuckDBPyConnection | DuckDBPyRelation, batch_size: int = 100) -> Iterator[tuple[Any, ...]]:
    # More efficient to call fetchmany() and then flatten
    while True:
        batch = src.fetchmany(batch_size)
        if not batch:
            break
        yield from batch

class ConnectionWithInit:
    """Wrap a DuckDBPyConnection and call execute(self._statement) on every cursor() created before returning it.

    The returned cursors will also be wrapped in an instance of this class.

    Instances of this class are valid connections on a protocol (i.e. duck typing) level, but are not instances
    of DuckDBPyConnection according to isinstance/type and cannot be passed as arguments to duckdb functions
    expecting real connections.

    Does NOT call execute(self._statement) on the original connection.
    """
    def __init__(self, conn: DuckDBPyConnection, statement: str) -> None:
        self._conn = conn
        self._statement = statement

    def __getattr__(self, name: str, /) -> Any:
        return getattr(self._conn, name)

    # Dunder methods we want to forward (__getattr__ isn't called for dunder methods)
    def __enter__(self) -> Self:
        self._conn.__enter__()
        return self

    def __exit__(self, exc_type: object, exc_val: object, exc_tb: object) -> None:
        return self._conn.__exit__(exc_type, exc_val, exc_tb)

    def cursor(self) -> ConnectionWithInit:
        curs = self._conn.cursor()
        try:
            curs.execute(self._statement)
        except:
            curs.close()
            raise
        return ConnectionWithInit(curs, self._statement)

    @staticmethod
    def use(conn: DuckDBPyConnection, namespace: str) -> ConnectionWithInit:
        """Issue a USE statement when creating a cursor.

        The namespace is NOT additionally quoted.
        """
        return ConnectionWithInit(conn, f'USE {namespace}')


class RowidNature(Enum):
    """Whether a relation has a rowid member.

    Relations with an explicitly defined column named rowid are COLUMN.
    Native duckdb tables with no explicitly defined column named rowid have an autogenerated column named that, PSEUDOCOLUMN.
    Other relations (e.g. from remote sources, or registered ones) don't have an accessible rowid member, NONE.
    """
    COLUMN = 1
    PSEUDOCOLUMN = 2
    NONE = 3

def test_rowid_nature(conn: DuckDBPyConnection, name: str) -> RowidNature:
    """The argument must be a relation name available on this connection.

    When passing a DuckdbName, remember to apply str().
    """
    rel = conn.table(name)
    if 'rowid' in rel.columns:
        return RowidNature.COLUMN
    else:
        try:
            conn.sql(f'select rowid from {name}')
            return RowidNature.PSEUDOCOLUMN
        except duckdb.BinderException:
            return RowidNature.NONE

@contextlib.contextmanager
def conn_timeout(conn: DuckDBPyConnection, timeout: datetime.timedelta) -> Generator[None, None, None]:
    """After a timeout, interrupts the ongoing query on this connection, unless the context is exited first.

    WARNING this is meant to work in a very specific situation:
    1. There is going to be a single execute() or fetchall() call inside the context.
       If there are multiple calls (eg a loop calling fetchmany() on a relation, or additional python code),
       the interruption might not happen when the thread is blocked on reading from the connection,
       in which case the interruption won't do anything and time spent inside the context could exceed the timeout.
    2. This connection object is going to be used, not any cursors created from it. In particular, cursors won't be
       created in order to pass them to other threads with asyncio.to_tread.
       The interruption will only affect the original connection object.
       (We can lift this requirement by registering additional connections to interrupt
       in a ConnectionWithInit-based implementation, but it does not seem useful right now.)
    3. The asyncio thread's event loop has been stored by calling asyncref.store_asyncio_event_loop, so that
       the current (presumably synchronous) thread can access it. This happens automatically inside a RunContext,
       so all our production code can assume this is the case.

    This function is meant to be called on a sync thread in the asyncio threadpool, and will raise an error if it is called
    on an async thread.
    """
    try:
        running_loop = asyncio.get_running_loop()
    except RuntimeError:
        running_loop = None
    if running_loop is not None:
        raise RuntimeError('This must not be called on an async thread; the blocking operation on the connection '
                           'will block the async thread from carrying out the timeout')


    def interrupt() -> None:
        conn.interrupt()

    with asyncref.on_timeout(timeout, interrupt):
        yield
